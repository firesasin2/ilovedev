
# Go 심화
<br/>

### 공개/비공개 법칙
  + 자료형, 변수, 상수, 함수, 메서드 모두에서 이름이 대문자로 시작하면 공개, 소문자로 시작한다면 비공개
<br/>

### init.go
  + 패키지 초기화: 패키지의 초기화 로직을 담당하며, 프로그램이 실행될 때 자동으로 호출됨(프로젝트의 루트 디렉토리나 패키지 디렉토리 내에 위치할 수 있음)
  + 전역 변수 초기화: var 키워드를 사용하여 전역 변수를 선언하고 기본값을 설정 할 수 있음.
  + 함수 초기화: 팩토리 메서드 또는 기타 초기화 코드를 포함하는 함수를 정의할 수 있음.
  + 여러파일 가능함
<br/>

### main.go
  + 실행 가능한 프로그램의 진입점(entry point)을 정의하는 파일
  + C의 main함수와 같음
<br/>

### go.mod
  + go의 모듈관리
  + mod 초기화 및 go.mod 파일 생성
    ```go
    go mod init {package name}
	  ```
  + go.sum 파일 생성
    ```go
    go build 
	  ```
  + 소스내 의존성을 go.mod 파일에 정리
    ```go
    go tidy
	  ```
  + go.sum 파일 유효성 검사
    ```go
    go mod verify
	  ```
<br/>

### cgo
  + cgo는 Go 코드에서 C 코드를 호출할 수 있게 해주는 Go 언어 기능
  + 장점
	- C 라이브러리 및 시스템 호출에 액세스할 수 있음.
	- 유연성과 확장성: Go의 간결함을 유지하면서 필요한 부분에 C 코드를 사용할 수 있음.
	- 성능: C 코드는 일반적으로 Go 코드보다 빠르므로 성능이 중요한 부분에 사용할 수 있음.
	- 하드웨어 및 시스템 액세스: C 라이브러리를 통해 하드웨어 장치 및 운영 체제 기능에 액세스할 수 있음.
<br/>

### Go 프레임워크
  + gin 가장 오랫동안 개발되어 왔으며 현재 Star 1위. 무거움
  + fiber fasthttp 기반, Express의 용이성과 Go의 원시 성능을 결합
  + echo
  + fasthttp
    - 높은 성능: 뛰어난 성능을 자랑하며, net/http보다 최대 10배 빠르다고 알려져 있음.
	- 낮은 메모리 사용량: 메모리 할당을 최소화하여 메모리 효율성이 뛰어남.
	- 간결한 인터페이스: 쉽고 명확한 API를 제공하여 코드 작성이 간단함.
	- 다양한 기능: 라우팅, 미들웨어, 쿠키, 세션, 바디 파서 등 웹 개발에 필요한 기능을 모두 제공함.
	- 커뮤니티 지원: 활발한 커뮤니티가 지원하여 문제 해결 및 정보 요청이 쉽음.
<br/>

### Go가 생산성이 높은 이유
  + 부분적이지만, 편리한 자료형 추론을 제공하여 굳이 반복해서 자료형 이름을 쓰지 않아도 됨
    ```go
    // 자료형을 명시하지 않고 문자열 변수 선언
    message := "Hello, Golang!"

    // 자료형을 명시하지 않고 정수 변수 선언
    number := 42

    // 자료형을 명시하지 않고 부동소수점 변수 선언
    pi := 3.14
    ```
  + 소스 코드 형식을 자동으로 맞춰주는 도구 및 여러 편리한 도구를 기본으로 제공
    + gofmt
      + Go 언어는 코드 형식을 표준화하기 위해 gofmt 도구를 제공. 
      + Go 언어에서 사용되는 코드 포맷터로서, 소스 코드를 특정한 스타일에 맞게 자동으로 정리해주는 도구. 
      + 코드의 일관된 형식을 유지하면서 코드 리뷰 및 협업이 용이
      + gofmt를 사용하는 주요 목적은 코드의 일관성과 가독성을 유지하는 것
        ```go
        gofmt -w .  // 현재 디렉토리와 하위 디렉토리의 모든 Go 소스 코드를 정해진 스타일에 맞게 수정
        ```
      + Visual Studio Code에서 Go extension을 사용하고 있다면, 일반적으로 소스를 저장할 때(go 파일에 한정) gofmt가 자동으로 수행됨
  + Example 테스트를 이용하여 쉽게 테스트 코드를 작성하면서 코드 문서화까지 할 수 있음
  + Go의 문서와
    ```bash
    godoc -http=:3000
    ```
  + 함수 리터럴 및 클로저를 자유자재로 사용 할 수 있음
    + Golang은 함수를 일급 시민(first-class citizens)으로 취급하며, 함수를 변수에 할당하고, 다른 함수의 인자로 전달하고, 함수에서 함수를 반환하는 등의 작업을 자유롭게 할 수 있음
    + 예제
      ```go
      package main

      import "fmt"

      func main() {
          // 함수 리터럴 (익명 함수)을 변수에 할당
          add := func(a, b int) int {
              return a + b
          }

          // 클로저 예제
          x := 10
          increment := func() int {
              x++
              return x
          }

          // 할당한 함수 리터럴 호출
          result := add(3, 5)
          fmt.Println("Addition result:", result)

          // 클로저 호출
          fmt.Println("Increment:", increment()) // 출력: 11
          fmt.Println("Increment:", increment()) // 출력: 12
          fmt.Println(x) // 출력: 12
      }
      ```
    + 클로저란?
      + 함수와 해당 함수가 참조하는 외부 변수(자유 변수)들로 이루어진 조합
      + 클로저는 외부 변수에 대한 참조를 기억하고, 이 참조를 통해 변수에 접근하고 수정할 수 있는 함수
        + 자유 변수(Free Variable) 참조
          + 클로저는 자신의 함수 본문에서 정의되지 않은 외부 변수에 접근할 수 있음
        + 자유 변수의 값 유지
          + 클로저는 자유 변수의 값을 기억
          +  클로저가 생성될 때 외부 변수의 값을 캡처하며, 이 값은 클로저의 생명주기 동안 유지
        + 익명 함수
          + 일반적으로 클로저는 익명 함수로 사용. 익명 함수는 변수에 할당되거나 함수 호출 시 직접 정의될 수 있음
  + 명시적으로 인터페이스를 지정하지 않아도 인터페이스 구현이 가능하여 기존에 있던 코드를 고치지 않고도 유연한 구현이 가능
    ```go
    package main

    import "fmt"

    // Printer 인터페이스 정의
    type Printer interface {
        Print()
    }

    // Person 타입 정의
    type Person struct {
        Name string
    }

    // Person 타입에 Print 메서드 추가
    func (p Person) Print() {
        fmt.Println(p.Name)
    }

    func main() {
        // 묵시적으로 Printer 인터페이스를 구현함
        var printer Printer = Person{Name: "John"}
        
        // 인터페이스 메서드 호출
        printer.Print() // 출력: John
    }
    // Person 타입은 명시적으로 Printer 인터페이스를 구현하겠다는 선언이 없지만, Print 메서드를 가지고 있기 때문에 자동으로 Printer 인터페이스를 구현하게 됨
    ```
  + 채널을 이용하여 동시성 구현을 락 등을 이용하지 않고 간편하게 할 수 있으며, 언어 고유의 지원으로 교착 상태나 경쟁 상태를 파악하기 쉬움